<!--
    ============================================================================
    ARCHIVO: 09-pareto.html
    ============================================================================
    
    PROPÓSITO:
    Demuestra gráficos de Pareto que combinan barras y línea acumulativa.
    Útil para identificar los elementos más importantes (regla 80/20).
    
    CARACTERÍSTICAS:
    - Barras ordenadas por valor descendente
    - Línea acumulativa que muestra el porcentaje acumulado
    - Línea de referencia al 80% para identificar elementos críticos
    - Dos ejes Y: uno para valores absolutos, otro para porcentajes
    
    CONCEPTOS CLAVE:
    - Ordenamiento: Datos ordenados por valor descendente
    - Acumulación: Calcular porcentaje acumulado progresivamente
    - Escalas duales: Dos escalas Y diferentes (valores y porcentajes)
    - createCustomYAxis: Para crear ejes Y personalizados
    
    DATOS:
    - paretoData: Array de {category, value, frequency}
    
    ============================================================================
-->
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gráficos de Pareto</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="../css/styles.css">
</head>
<body>
    <div class="example-page">
        <a href="../index.html" class="back-link">← Volver al índice</a>
        
        <div class="example-header">
            <h1>9. Gráficos de Pareto</h1>
            <p>Regla 80/20: pocos elementos generan la mayor parte del efecto</p>
        </div>

        <div class="chart-container">
            <h2>Gráfico de Pareto</h2>
            <p>Barras ordenadas por frecuencia + línea acumulativa.</p>
            <div id="chart1" class="chart-wrapper"></div>
        </div>

        <div class="chart-container">
            <h2>Pareto con Regla 80/20 Visualizada</h2>
            <p>Línea de referencia al 80% para identificar elementos críticos.</p>
            <div id="chart2" class="chart-wrapper"></div>
        </div>

        <script src="../js/config.js"></script>
        <script src="../js/utils.js"></script>
        <script src="../js/axes.js"></script>
        <script>
            // Esperar a que el DOM esté listo
            document.addEventListener('DOMContentLoaded', function() {
                // Verificar que D3 y las funciones estén disponibles
                if (typeof d3 === 'undefined') {
                    console.error('D3.js no está cargado');
                    return;
                }
                if (typeof createSVG === 'undefined') {
                    console.error('createSVG no está disponible');
                    return;
                }
                if (typeof createGrid === 'undefined') {
                    console.error('createGrid no está disponible');
                    return;
                }
                if (typeof createCustomYAxis === 'undefined') {
                    console.error('createCustomYAxis no está disponible');
                    return;
                }
                if (typeof createCustomXAxis === 'undefined') {
                    console.error('createCustomXAxis no está disponible');
                    return;
                }
                
                // Cargar datos
                d3.json('../data/sample-data.json')
                    .then(data => {
                        if (!data) {
                            console.error('No se pudieron cargar los datos');
                            return;
                        }
                        
                        const paretoData = data.paretoData;
                        if (!paretoData || paretoData.length === 0) {
                            console.error('No hay datos para los gráficos de Pareto');
                            return;
                        }
                        
                        console.log('Datos de Pareto cargados:', paretoData);

                // Ejemplo 1: Gráfico de Pareto básico
                const { svg: svg1, g: g1, dims: dims1 } = createSVG('#chart1', 700, 400);

                // Ordenar por valor descendente
                const sortedData = [...paretoData].sort((a, b) => b.value - a.value);
                
                // Calcular valores acumulativos
                let cumulative = 0;
                const total = d3.sum(sortedData, d => d.value);
                const paretoDataWithCumulative = sortedData.map(d => {
                    cumulative += d.value;
                    return {
                        ...d,
                        cumulative: cumulative,
                        cumulativePercent: cumulative / total
                    };
                });

                const xScale1 = d3.scaleBand()
                    .domain(paretoDataWithCumulative.map(d => d.category))
                    .range([0, dims1.innerWidth])
                    .padding(0.2);

                const yScale1 = d3.scaleLinear()
                    .domain([0, d3.max(paretoDataWithCumulative, d => d.value)])
                    .nice()
                    .range([dims1.innerHeight, 0]);

                const yScale1Percent = d3.scaleLinear()
                    .domain([0, 1])
                    .range([dims1.innerHeight, 0]);

                createGrid(g1, xScale1, yScale1, dims1);

                // Barras
                g1.selectAll('rect')
                    .data(paretoDataWithCumulative)
                    .enter()
                    .append('rect')
                    .attr('x', d => xScale1(d.category))
                    .attr('y', d => yScale1(d.value))
                    .attr('width', xScale1.bandwidth())
                    .attr('height', d => dims1.innerHeight - yScale1(d.value))
                    .style('fill', '#4a90e2')
                    .style('stroke', '#357abd')
                    .style('stroke-width', 1);

                // Línea acumulativa
                const line1 = d3.line()
                    .x(d => xScale1(d.category) + xScale1.bandwidth() / 2)
                    .y(d => yScale1Percent(d.cumulativePercent))
                    .curve(d3.curveMonotoneX);

                g1.append('path')
                    .datum(paretoDataWithCumulative)
                    .attr('fill', 'none')
                    .attr('stroke', '#f39c12')
                    .attr('stroke-width', 3)
                    .attr('d', line1);

                // Puntos en la línea
                g1.selectAll('.cumulative-point')
                    .data(paretoDataWithCumulative)
                    .enter()
                    .append('circle')
                    .attr('class', 'cumulative-point')
                    .attr('cx', d => xScale1(d.category) + xScale1.bandwidth() / 2)
                    .attr('cy', d => yScale1Percent(d.cumulativePercent))
                    .attr('r', 5)
                    .style('fill', '#f39c12')
                    .style('stroke', 'white')
                    .style('stroke-width', 2);

                // Eje Y izquierdo (valores)
                createCustomYAxis(g1, yScale1, dims1, {
                    label: 'Frecuencia',
                    position: 'left'
                });

                // Eje Y derecho (porcentaje acumulativo)
                const yAxisRight = d3.axisRight(yScale1Percent)
                    .tickFormat(d3.format('.0%'))
                    .ticks(5);

                g1.append('g')
                    .attr('class', 'y-axis-right')
                    .attr('transform', `translate(${dims1.innerWidth}, 0)`)
                    .call(yAxisRight);

                g1.append('text')
                    .attr('class', 'axis-label')
                    .attr('transform', 'rotate(90)')
                    .attr('y', dims1.innerWidth + dims1.margin.right - 10)
                    .attr('x', dims1.innerHeight / 2)
                    .attr('dy', '1em')
                    .style('text-anchor', 'middle')
                    .style('font-size', '14px')
                    .style('font-weight', 'bold')
                    .style('fill', '#f39c12')
                    .text('Porcentaje Acumulativo');

                createCustomXAxis(g1, xScale1, dims1, {
                    label: 'Categorías',
                    rotate: -45
                });

                // Ejemplo 2: Pareto con línea 80/20
                const { svg: svg2, g: g2, dims: dims2 } = createSVG('#chart2', 700, 400);

                const xScale2 = d3.scaleBand()
                    .domain(paretoDataWithCumulative.map(d => d.category))
                    .range([0, dims2.innerWidth])
                    .padding(0.2);

                const yScale2 = d3.scaleLinear()
                    .domain([0, d3.max(paretoDataWithCumulative, d => d.value)])
                    .nice()
                    .range([dims2.innerHeight, 0]);

                const yScale2Percent = d3.scaleLinear()
                    .domain([0, 1])
                    .range([dims2.innerHeight, 0]);

                createGrid(g2, xScale2, yScale2, dims2);

                // Barras con colores según regla 80/20
                g2.selectAll('rect')
                    .data(paretoDataWithCumulative)
                    .enter()
                    .append('rect')
                    .attr('x', d => xScale2(d.category))
                    .attr('y', d => yScale2(d.value))
                    .attr('width', xScale2.bandwidth())
                    .attr('height', d => dims2.innerHeight - yScale2(d.value))
                    .style('fill', d => d.cumulativePercent <= 0.8 ? '#4caf50' : '#9e9e9e')
                    .style('stroke', '#333')
                    .style('stroke-width', 1);

                // Línea acumulativa
                const line2 = d3.line()
                    .x(d => xScale2(d.category) + xScale2.bandwidth() / 2)
                    .y(d => yScale2Percent(d.cumulativePercent))
                    .curve(d3.curveMonotoneX);

                g2.append('path')
                    .datum(paretoDataWithCumulative)
                    .attr('fill', 'none')
                    .attr('stroke', '#f39c12')
                    .attr('stroke-width', 3)
                    .attr('d', line2);

                // Línea de referencia al 80%
                g2.append('line')
                    .attr('x1', 0)
                    .attr('x2', dims2.innerWidth)
                    .attr('y1', yScale2Percent(0.8))
                    .attr('y2', yScale2Percent(0.8))
                    .style('stroke', '#f44336')
                    .style('stroke-width', 2)
                    .style('stroke-dasharray', '5,5');

                g2.append('text')
                    .attr('x', dims2.innerWidth - 10)
                    .attr('y', yScale2Percent(0.8) - 5)
                    .attr('text-anchor', 'end')
                    .style('font-size', '12px')
                    .style('font-weight', 'bold')
                    .style('fill', '#f44336')
                    .text('80%');

                // Puntos en la línea
                g2.selectAll('.cumulative-point')
                    .data(paretoDataWithCumulative)
                    .enter()
                    .append('circle')
                    .attr('class', 'cumulative-point')
                    .attr('cx', d => xScale2(d.category) + xScale2.bandwidth() / 2)
                    .attr('cy', d => yScale2Percent(d.cumulativePercent))
                    .attr('r', 5)
                    .style('fill', '#f39c12')
                    .style('stroke', 'white')
                    .style('stroke-width', 2);

                // Tooltip
                const tooltip2 = createTooltip('body');

                g2.selectAll('rect')
                    .on('mouseover', function(event, d) {
                        d3.select(this).style('opacity', 0.7);
                        showTooltip(tooltip2, `
                            <strong>${d.category}</strong><br>
                            Valor: ${d.value}<br>
                            Acumulado: ${d3.format('.1%')(d.cumulativePercent)}
                        `, event);
                    })
                    .on('mousemove', function(event) {
                        showTooltip(tooltip2, tooltip2.html(), event);
                    })
                    .on('mouseout', function() {
                        d3.select(this).style('opacity', 1);
                        hideTooltip(tooltip2);
                    });

                // Ejes
                createCustomYAxis(g2, yScale2, dims2, {
                    label: 'Frecuencia',
                    position: 'left'
                });

                const yAxisRight2 = d3.axisRight(yScale2Percent)
                    .tickFormat(d3.format('.0%'))
                    .ticks(5);

                g2.append('g')
                    .attr('class', 'y-axis-right')
                    .attr('transform', `translate(${dims2.innerWidth}, 0)`)
                    .call(yAxisRight2);

                createCustomXAxis(g2, xScale2, dims2, {
                    label: 'Categorías',
                    rotate: -45
                });

                // Leyenda
                const legend2 = g2.append('g')
                    .attr('transform', `translate(${dims2.innerWidth - 150}, 20)`);

                ['Críticos (≤80%)', 'No críticos (>80%)'].forEach((label, i) => {
                    const colors = ['#4caf50', '#9e9e9e'];
                    const legendItem = legend2.append('g')
                        .attr('transform', `translate(0, ${i * 25})`);
                    
                    legendItem.append('rect')
                        .attr('width', 15)
                        .attr('height', 15)
                        .style('fill', colors[i]);
                    
                    legendItem.append('text')
                        .attr('x', 20)
                        .attr('y', 12)
                        .style('font-size', '12px')
                        .text(label);
                });
                    })
                    .catch(error => {
                        console.error('Error al cargar los datos:', error);
                        // Mostrar mensaje de error en la página
                        document.querySelectorAll('.chart-wrapper').forEach(wrapper => {
                            wrapper.innerHTML = '<p style="color: red; padding: 20px;">Error al cargar los datos. Por favor, verifica que el servidor esté ejecutándose correctamente.</p>';
                        });
                    });
            });
        </script>
    </div>
</body>
</html>

