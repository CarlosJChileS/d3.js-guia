<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gráficos de Cascada</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="../css/styles.css">
</head>
<body>
    <div class="example-page">
        <a href="../index.html" class="back-link">← Volver al índice</a>
        
        <div class="example-header">
            <h1>11. Gráficos de Cascada</h1>
            <p>Visualización de cambios acumulativos paso a paso</p>
        </div>

        <div class="chart-container">
            <h2>Gráfico de Cascada</h2>
            <p>Muestra cómo un valor inicial se modifica por una serie de cambios.</p>
            <div id="chart1" class="chart-wrapper"></div>
        </div>

        <script src="../js/config.js"></script>
        <script src="../js/utils.js"></script>
        <script src="../js/axes.js"></script>
        <script>
            // Esperar a que el DOM esté listo
            document.addEventListener('DOMContentLoaded', function() {
                // Verificar que D3 y las funciones estén disponibles
                if (typeof d3 === 'undefined') {
                    console.error('D3.js no está cargado');
                    return;
                }
                if (typeof createSVG === 'undefined') {
                    console.error('createSVG no está disponible');
                    return;
                }
                if (typeof createGrid === 'undefined') {
                    console.error('createGrid no está disponible');
                    return;
                }
                if (typeof createAxes === 'undefined') {
                    console.error('createAxes no está disponible');
                    return;
                }
                
                // Cargar datos
                d3.json('../data/sample-data.json')
                    .then(data => {
                        if (!data) {
                            console.error('No se pudieron cargar los datos');
                            return;
                        }
                        
                        const waterfallData = data.waterfallData;
                        if (!waterfallData || waterfallData.length === 0) {
                            console.error('No hay datos para el gráfico de cascada');
                            return;
                        }
                        
                        console.log('Datos de cascada cargados:', waterfallData);

                const { svg: svg1, g: g1, dims: dims1 } = createSVG('#chart1', 800, 500);

                // Calcular posiciones acumulativas
                let runningTotal = 0;
                const processedData = waterfallData.map((d, i) => {
                    let startY, endY, height, color;
                    
                    if (d.type === 'start') {
                        startY = runningTotal;
                        runningTotal += d.value;
                        endY = runningTotal;
                        height = d.value;
                        color = '#9e9e9e';
                    } else if (d.type === 'end') {
                        startY = runningTotal;
                        endY = runningTotal;
                        height = 0;
                        color = '#4a90e2';
                    } else if (d.type === 'positive') {
                        startY = runningTotal;
                        runningTotal += d.value;
                        endY = runningTotal;
                        height = d.value;
                        color = '#4caf50';
                    } else if (d.type === 'negative') {
                        startY = runningTotal;
                        runningTotal += d.value;
                        endY = runningTotal;
                        height = Math.abs(d.value);
                        color = '#f44336';
                    }

                    return {
                        ...d,
                        startY: startY,
                        endY: endY,
                        height: height,
                        color: color,
                        runningTotal: runningTotal
                    };
                });

                const allValues = processedData.flatMap(d => [d.startY, d.endY]);
                const maxValue = d3.max(allValues);
                const minValue = d3.min(allValues);

                const xScale = d3.scaleBand()
                    .domain(processedData.map(d => d.label))
                    .range([0, dims1.innerWidth])
                    .padding(0.3);

                const yScale = d3.scaleLinear()
                    .domain([minValue, maxValue])
                    .nice()
                    .range([dims1.innerHeight, 0]);

                createGrid(g1, xScale, yScale, dims1);

                // Dibujar barras
                processedData.forEach((d, i) => {
                    if (d.type === 'end') {
                        // Punto final
                        g1.append('circle')
                            .attr('cx', xScale(d.label) + xScale.bandwidth() / 2)
                            .attr('cy', yScale(d.endY))
                            .attr('r', 6)
                            .style('fill', d.color)
                            .style('stroke', '#333')
                            .style('stroke-width', 2);
                    } else if (d.height > 0) {
                        // Barra
                        const barWidth = xScale.bandwidth() * 0.6;
                        const barX = xScale(d.label) + (xScale.bandwidth() - barWidth) / 2;
                        const barY = d.type === 'negative' ? yScale(d.endY) : yScale(d.startY);
                        const barHeight = Math.abs(yScale(d.endY) - yScale(d.startY));

                        g1.append('rect')
                            .attr('x', barX)
                            .attr('y', barY)
                            .attr('width', barWidth)
                            .attr('height', barHeight)
                            .style('fill', d.color)
                            .style('fill-opacity', 0.7)
                            .style('stroke', '#333')
                            .style('stroke-width', 1);

                        // Línea conectora (excepto para el primero)
                        if (i > 0 && processedData[i - 1].type !== 'start') {
                            const prevX = xScale(processedData[i - 1].label) + xScale.bandwidth() / 2;
                            const currX = xScale(d.label) + xScale.bandwidth() / 2;
                            const y = yScale(d.startY);

                            g1.append('line')
                                .attr('x1', prevX)
                                .attr('x2', currX)
                                .attr('y1', y)
                                .attr('y2', y)
                                .style('stroke', '#666')
                                .style('stroke-width', 2)
                                .style('stroke-dasharray', '3,3');
                        }
                    }

                    // Etiqueta de valor
                    if (d.type !== 'end' || i === processedData.length - 1) {
                        const labelY = d.type === 'negative' ? yScale(d.endY) - 5 : yScale(d.startY) - 5;
                        g1.append('text')
                            .attr('x', xScale(d.label) + xScale.bandwidth() / 2)
                            .attr('y', labelY)
                            .attr('text-anchor', 'middle')
                            .style('font-size', '11px')
                            .style('font-weight', 'bold')
                            .text(d.value !== 0 ? (d.value > 0 ? '+' : '') + d.value : d.value);
                    }

                    // Etiqueta de total acumulativo
                    if (d.type === 'end' || i === processedData.length - 1) {
                        g1.append('text')
                            .attr('x', xScale(d.label) + xScale.bandwidth() / 2)
                            .attr('y', yScale(d.endY) - 20)
                            .attr('text-anchor', 'middle')
                            .style('font-size', '12px')
                            .style('font-weight', 'bold')
                            .style('fill', '#4a90e2')
                            .text(`Total: ${d.endY}`);
                    }
                });

                // Ejes
                createAxes(g1, xScale, yScale, dims1, {
                    xLabel: 'Categorías',
                    yLabel: 'Valor',
                    rotateXLabels: true
                });

                // Leyenda
                const legend = g1.append('g')
                    .attr('transform', `translate(${dims1.innerWidth - 150}, 20)`);

                const legendItems = [
                    { label: 'Inicio', color: '#9e9e9e' },
                    { label: 'Positivo', color: '#4caf50' },
                    { label: 'Negativo', color: '#f44336' },
                    { label: 'Final', color: '#4a90e2' }
                ];

                legendItems.forEach((item, i) => {
                    const legendItem = legend.append('g')
                        .attr('transform', `translate(0, ${i * 25})`);
                    
                    legendItem.append('rect')
                        .attr('width', 15)
                        .attr('height', 15)
                        .style('fill', item.color)
                        .style('fill-opacity', item.label === 'Final' ? 1 : 0.7)
                        .style('stroke', '#333');
                    
                    legendItem.append('text')
                        .attr('x', 20)
                        .attr('y', 12)
                        .style('font-size', '12px')
                        .text(item.label);
                });
                    })
                    .catch(error => {
                        console.error('Error al cargar los datos:', error);
                        // Mostrar mensaje de error en la página
                        document.querySelectorAll('.chart-wrapper').forEach(wrapper => {
                            wrapper.innerHTML = '<p style="color: red; padding: 20px;">Error al cargar los datos. Por favor, verifica que el servidor esté ejecutándose correctamente.</p>';
                        });
                    });
            });
        </script>
    </div>
</body>
</html>

