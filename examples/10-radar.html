<!--
    ============================================================================
    ARCHIVO: 10-radar.html
    ============================================================================
    
    PROPÓSITO:
    Demuestra gráficos de radar (spider charts) que visualizan datos
    multidimensionales en forma de polígono radial.
    
    CARACTERÍSTICAS:
    - Ejes radiales: Cada dimensión tiene su propio eje desde el centro
    - Polígono: Conecta los valores de cada dimensión
    - Área rellena: Opcional, muestra el área cubierta
    - Niveles concéntricos: Círculos de referencia para valores
    
    TÉCNICAS:
    - Coordenadas polares: Conversión de ángulos y radios a (x, y)
    - d3.lineRadial(): Generador de líneas en coordenadas polares
    - Transformaciones: Rotación y escalado para posicionar dimensiones
    
    USOS:
    - Comparar múltiples series en las mismas dimensiones
    - Visualizar perfiles multidimensionales
    - Análisis de rendimiento en múltiples métricas
    
    DATOS:
    - radarData: Objeto con series como claves y objetos de dimensiones
    
    ============================================================================
-->
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gráficos de Radar</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="../css/styles.css">
</head>
<body>
    <div class="example-page">
        <a href="../index.html" class="back-link">← Volver al índice</a>
        
        <div class="example-header">
            <h1>10. Gráficos de Radar</h1>
            <p>Visualización multidimensional en forma de polígono</p>
        </div>

        <div class="chart-container">
            <h2>Gráfico de Radar Básico</h2>
            <p>Una serie de datos con múltiples dimensiones.</p>
            <div id="chart1" class="chart-wrapper"></div>
        </div>

        <div class="chart-container">
            <h2>Gráfico de Radar Múltiple</h2>
            <p>Comparación de múltiples series.</p>
            <div id="chart2" class="chart-wrapper"></div>
        </div>

        <script src="../js/config.js"></script>
        <script src="../js/utils.js"></script>
        <script>
            // Cargar datos
            d3.json('../data/sample-data.json').then(data => {
                const radarData = data.radarData;

                // Función para crear gráfico de radar
                function createRadarChart(container, data, options = {}) {
                    const {
                        width = 500,
                        height = 500,
                        maxValue = 100,
                        levels = 5,
                        showArea = true,
                        showPoints = true,
                        showLabels = true
                    } = options;

                    const { svg, g, dims } = createSVG(container, width, height, { top: 20, right: 20, bottom: 20, left: 20 });

                    const radius = Math.min(dims.innerWidth, dims.innerHeight) / 2 - 40;
                    const centerX = dims.innerWidth / 2;
                    const centerY = dims.innerHeight / 2;

                    // Obtener dimensiones (claves)
                    const dimensions = Object.keys(data);
                    const angleStep = (2 * Math.PI) / dimensions.length;

                    // Escala radial
                    const rScale = d3.scaleLinear()
                        .domain([0, maxValue])
                        .range([0, radius]);

                    // Dibujar niveles (círculos concéntricos)
                    for (let i = 0; i <= levels; i++) {
                        const level = (i / levels) * maxValue;
                        const levelRadius = rScale(level);
                        
                        g.append('circle')
                            .attr('cx', centerX)
                            .attr('cy', centerY)
                            .attr('r', levelRadius)
                            .style('fill', 'none')
                            .style('stroke', '#e0e0e0')
                            .style('stroke-width', 1);

                        if (i > 0) {
                            g.append('text')
                                .attr('x', centerX)
                                .attr('y', centerY - levelRadius - 5)
                                .attr('text-anchor', 'middle')
                                .style('font-size', '10px')
                                .style('fill', '#666')
                                .text(Math.round(level));
                        }
                    }

                    // Dibujar ejes radiales
                    dimensions.forEach((dim, i) => {
                        const angle = i * angleStep - Math.PI / 2;
                        const x = centerX + Math.cos(angle) * radius;
                        const y = centerY + Math.sin(angle) * radius;

                        g.append('line')
                            .attr('x1', centerX)
                            .attr('y1', centerY)
                            .attr('x2', x)
                            .attr('y2', y)
                            .style('stroke', '#e0e0e0')
                            .style('stroke-width', 1);

                        if (showLabels) {
                            g.append('text')
                                .attr('x', centerX + Math.cos(angle) * (radius + 20))
                                .attr('y', centerY + Math.sin(angle) * (radius + 20))
                                .attr('text-anchor', 'middle')
                                .style('font-size', '12px')
                                .style('font-weight', 'bold')
                                .text(dim);
                        }
                    });

                    // Función para convertir datos a coordenadas
                    function getCoordinates(value, index) {
                        const angle = index * angleStep - Math.PI / 2;
                        const r = rScale(value);
                        return {
                            x: centerX + Math.cos(angle) * r,
                            y: centerY + Math.sin(angle) * r
                        };
                    }

                    // Crear polígono
                    const points = dimensions.map((dim, i) => {
                        const coords = getCoordinates(data[dim], i);
                        return [coords.x, coords.y];
                    });

                    // Área
                    if (showArea) {
                        const area = d3.area()
                            .x(d => d[0])
                            .y(d => d[1])
                            .curve(d3.curveLinearClosed);

                        g.append('path')
                            .datum(points)
                            .attr('d', area)
                            .style('fill', '#4a90e2')
                            .style('fill-opacity', 0.3)
                            .style('stroke', '#357abd')
                            .style('stroke-width', 2);
                    } else {
                        // Solo línea
                        const line = d3.line()
                            .x(d => d[0])
                            .y(d => d[1])
                            .curve(d3.curveLinearClosed);

                        g.append('path')
                            .datum(points)
                            .attr('d', line)
                            .style('fill', 'none')
                            .style('stroke', '#4a90e2')
                            .style('stroke-width', 2);
                    }

                    // Puntos
                    if (showPoints) {
                        dimensions.forEach((dim, i) => {
                            const coords = getCoordinates(data[dim], i);
                            g.append('circle')
                                .attr('cx', coords.x)
                                .attr('cy', coords.y)
                                .attr('r', 4)
                                .style('fill', '#357abd')
                                .style('stroke', 'white')
                                .style('stroke-width', 2);
                        });
                    }

                    return { svg, g, centerX, centerY, radius, rScale, angleStep, dimensions };
                }

                // Ejemplo 1: Radar básico
                const serie1 = radarData['Serie 1'];
                createRadarChart('#chart1', serie1, {
                    width: 600,
                    height: 600,
                    maxValue: 100,
                    levels: 5,
                    showArea: true,
                    showPoints: true
                });

                // Ejemplo 2: Radar múltiple
                const { svg: svg2, g: g2, dims: dims2 } = createSVG('#chart2', 700, 700, { top: 20, right: 20, bottom: 20, left: 20 });

                const radius2 = Math.min(dims2.innerWidth, dims2.innerHeight) / 2 - 40;
                const centerX2 = dims2.innerWidth / 2;
                const centerY2 = dims2.innerHeight / 2;

                const series = Object.keys(radarData);
                const dimensions2 = Object.keys(radarData[series[0]]);
                const angleStep2 = (2 * Math.PI) / dimensions2.length;

                const rScale2 = d3.scaleLinear()
                    .domain([0, 100])
                    .range([0, radius2]);

                // Niveles
                for (let i = 0; i <= 5; i++) {
                    const level = (i / 5) * 100;
                    const levelRadius = rScale2(level);
                    
                    g2.append('circle')
                        .attr('cx', centerX2)
                        .attr('cy', centerY2)
                        .attr('r', levelRadius)
                        .style('fill', 'none')
                        .style('stroke', '#e0e0e0')
                        .style('stroke-width', 1);

                    if (i > 0) {
                        g2.append('text')
                            .attr('x', centerX2)
                            .attr('y', centerY2 - levelRadius - 5)
                            .attr('text-anchor', 'middle')
                            .style('font-size', '10px')
                            .style('fill', '#666')
                            .text(Math.round(level));
                    }
                }

                // Ejes
                dimensions2.forEach((dim, i) => {
                    const angle = i * angleStep2 - Math.PI / 2;
                    const x = centerX2 + Math.cos(angle) * radius2;
                    const y = centerY2 + Math.sin(angle) * radius2;

                    g2.append('line')
                        .attr('x1', centerX2)
                        .attr('y1', centerY2)
                        .attr('x2', x)
                        .attr('y2', y)
                        .style('stroke', '#e0e0e0')
                        .style('stroke-width', 1);

                    g2.append('text')
                        .attr('x', centerX2 + Math.cos(angle) * (radius2 + 20))
                        .attr('y', centerY2 + Math.sin(angle) * (radius2 + 20))
                        .attr('text-anchor', 'middle')
                        .style('font-size', '12px')
                        .style('font-weight', 'bold')
                        .text(dim);
                });

                // Colores para cada serie
                const colors = D3Config.colors.categorical;

                // Dibujar cada serie
                series.forEach((serieName, serieIndex) => {
                    const serieData = radarData[serieName];
                    
                    function getCoords(value, index) {
                        const angle = index * angleStep2 - Math.PI / 2;
                        const r = rScale2(value);
                        return [centerX2 + Math.cos(angle) * r, centerY2 + Math.sin(angle) * r];
                    }

                    const points = dimensions2.map((dim, i) => getCoords(serieData[dim], i));

                    // Área
                    const area = d3.area()
                        .x(d => d[0])
                        .y(d => d[1])
                        .curve(d3.curveLinearClosed);

                    g2.append('path')
                        .datum(points)
                        .attr('d', area)
                        .style('fill', colors[serieIndex])
                        .style('fill-opacity', 0.2)
                        .style('stroke', colors[serieIndex])
                        .style('stroke-width', 2);

                    // Puntos
                    dimensions2.forEach((dim, i) => {
                        const coords = getCoords(serieData[dim], i);
                        g2.append('circle')
                            .attr('cx', coords[0])
                            .attr('cy', coords[1])
                            .attr('r', 4)
                            .style('fill', colors[serieIndex])
                            .style('stroke', 'white')
                            .style('stroke-width', 2);
                    });
                });

                // Leyenda
                const legend2 = g2.append('g')
                    .attr('transform', `translate(${dims2.innerWidth - 150}, 20)`);

                series.forEach((serieName, i) => {
                    const legendItem = legend2.append('g')
                        .attr('transform', `translate(0, ${i * 25})`);
                    
                    legendItem.append('rect')
                        .attr('width', 15)
                        .attr('height', 15)
                        .style('fill', colors[i])
                        .style('fill-opacity', 0.2)
                        .style('stroke', colors[i]);
                    
                    legendItem.append('text')
                        .attr('x', 20)
                        .attr('y', 12)
                        .style('font-size', '12px')
                        .text(serieName);
                });
            });
        </script>
    </div>
</body>
</html>

